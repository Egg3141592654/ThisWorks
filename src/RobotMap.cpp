// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<SpeedController> RobotMap::driveDriveMotorL1;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotorL2;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotorR1;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotorR2;
std::shared_ptr<RobotDrive> RobotMap::driveRobotDrive41;
std::shared_ptr<DoubleSolenoid> RobotMap::wheelieBarSOLENOID_WHEELIEBAR;
std::shared_ptr<DoubleSolenoid> RobotMap::fingerSOLENOID_FINGER;
std::shared_ptr<DoubleSolenoid> RobotMap::elevatorSOLENOID_ELEVATOR;
std::shared_ptr<Compressor> RobotMap::pneumaticsCOMPRESSOR;
std::shared_ptr<SpeedController> RobotMap::armARM_MOTOR_1;
std::shared_ptr<SpeedController> RobotMap::armARM_MOTOR_2;
std::shared_ptr<SpeedController> RobotMap::collectorCOLLECTOR;
std::shared_ptr<Encoder> RobotMap::encoder;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    LiveWindow *lw = LiveWindow::GetInstance();

    driveDriveMotorL1.reset(new VictorSP(7));
    lw->AddActuator("Drive", "DriveMotorL1", std::static_pointer_cast<VictorSP>(driveDriveMotorL1));
    
    driveDriveMotorL2.reset(new VictorSP(4));
    lw->AddActuator("Drive", "DriveMotorL2", std::static_pointer_cast<VictorSP>(driveDriveMotorL2));
    
    driveDriveMotorR1.reset(new VictorSP(8));
    lw->AddActuator("Drive", "DriveMotorR1", std::static_pointer_cast<VictorSP>(driveDriveMotorR1));
    
    driveDriveMotorR2.reset(new VictorSP(0));
    lw->AddActuator("Drive", "DriveMotorR2", std::static_pointer_cast<VictorSP>(driveDriveMotorR2));
    
    /*driveRobotDrive41.reset(new RobotDrive(driveDriveMotorL1, driveDriveMotorL2,
              driveDriveMotorR1, driveDriveMotorR2));
    
    // driveRobotDrive41->SetSafetyEnabled(true);
        driveRobotDrive41->SetExpiration(0.1);
        driveRobotDrive41->SetSensitivity(0.5);
        driveRobotDrive41->SetMaxOutput(1.0);

        driveRobotDrive41->SetInvertedMotor(RobotDrive::kFrontRightMotor, true);

        driveRobotDrive41->SetInvertedMotor(RobotDrive::kRearRightMotor, true);*/


    wheelieBarSOLENOID_WHEELIEBAR.reset(new DoubleSolenoid(0, 1, 4));
    lw->AddActuator("WheelieBar", "SOLENOID_WHEELIEBAR", wheelieBarSOLENOID_WHEELIEBAR);
    
    fingerSOLENOID_FINGER.reset(new DoubleSolenoid(0, 0, 3));
    lw->AddActuator("Finger", "SOLENOID_FINGER", fingerSOLENOID_FINGER);
    
    elevatorSOLENOID_ELEVATOR.reset(new DoubleSolenoid(0, 2, 5));
    lw->AddActuator("Elevator", "SOLENOID_ELEVATOR", elevatorSOLENOID_ELEVATOR);
    
    pneumaticsCOMPRESSOR.reset(new Compressor(0));
    
    
    armARM_MOTOR_1.reset(new VictorSP(5));
    armARM_MOTOR_1->SetInverted(true);
    lw->AddActuator("Arm", "ARM_MOTOR_1", std::static_pointer_cast<VictorSP>(armARM_MOTOR_1));
    
    armARM_MOTOR_2.reset(new VictorSP(9));
    armARM_MOTOR_2->SetInverted(false);
    lw->AddActuator("Arm", "ARM_MOTOR_2", std::static_pointer_cast<VictorSP>(armARM_MOTOR_2));
    
    collectorCOLLECTOR.reset(new VictorSP(1));
    lw->AddActuator("Collector", "COLLECTOR", std::static_pointer_cast<VictorSP>(collectorCOLLECTOR));
    

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    encoder.reset(new Encoder(10, 11, false, Encoder::k4X));
    lw->AddSensor("Arm", "encoder", encoder);
    encoder->SetDistancePerPulse(0.1875);
    encoder->SetPIDSourceType(PIDSourceType::kDisplacement);
    encoder->SetReverseDirection(true);
    }
