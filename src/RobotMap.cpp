// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"

std::shared_ptr<SpeedController> RobotMap::driveDriveMotorL1;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotorL2;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotorR1;
std::shared_ptr<SpeedController> RobotMap::driveDriveMotorR2;
std::shared_ptr<RobotDrive> RobotMap::driveRobotDrive41;
std::shared_ptr<DoubleSolenoid> RobotMap::wheelieBarSolenoid;
std::shared_ptr<DoubleSolenoid> RobotMap::fingerSolenoid;
std::shared_ptr<DoubleSolenoid> RobotMap::elevatorSolenoid;
std::shared_ptr<Compressor> RobotMap::compressor;
std::shared_ptr<SpeedController> RobotMap::armMotor1;
std::shared_ptr<SpeedController> RobotMap::armMotor2;
std::shared_ptr<SpeedController> RobotMap::collectorMotor;
std::shared_ptr<Encoder> RobotMap::encoder;

void RobotMap::init() {
    LiveWindow *lw = LiveWindow::GetInstance();

    driveDriveMotorL1.reset(new VictorSP(MOTOR_L1_PORT));
    lw->AddActuator("Drive", "DriveMotorL1", std::static_pointer_cast<VictorSP>(driveDriveMotorL1));
    
    driveDriveMotorL2.reset(new VictorSP(MOTOR_L2_PORT));
    lw->AddActuator("Drive", "DriveMotorL2", std::static_pointer_cast<VictorSP>(driveDriveMotorL2));
    
    driveDriveMotorR1.reset(new VictorSP(MOTOR_R1_PORT));
    lw->AddActuator("Drive", "DriveMotorR1", std::static_pointer_cast<VictorSP>(driveDriveMotorR1));
    
    driveDriveMotorR2.reset(new VictorSP(MOTOR_R2_PORT));
    lw->AddActuator("Drive", "DriveMotorR2", std::static_pointer_cast<VictorSP>(driveDriveMotorR2));

    wheelieBarSolenoid.reset(new DoubleSolenoid(0, WHEELIE_PORT_FORWARD, WHEELIE_PORT_REVERSE));
    lw->AddActuator("WheelieBar", "SOLENOID_WHEELIEBAR", wheelieBarSolenoid);
    
    fingerSolenoid.reset(new DoubleSolenoid(0, FINGER_PORT_FORWARD, FINGER_PORT_REVERSE));
    lw->AddActuator("Finger", "SOLENOID_FINGER", fingerSolenoid);
    
    elevatorSolenoid.reset(new DoubleSolenoid(0, ELEVATOR_PORT_FORWARD, ELEVATOR_PORT_REVERSE));
    lw->AddActuator("Elevator", "SOLENOID_ELEVATOR", elevatorSolenoid);
    
    compressor.reset(new Compressor(0));
    
    armMotor1.reset(new VictorSP(MOTOR_ARM1_PORT));
    armMotor1->SetInverted(true);
    lw->AddActuator("Arm", "ARM_MOTOR_1", std::static_pointer_cast<VictorSP>(armMotor1));
    
    armMotor2.reset(new VictorSP(MOTOR_ARM2_PORT));
    armMotor2->SetInverted(false);
    lw->AddActuator("Arm", "ARM_MOTOR_2", std::static_pointer_cast<VictorSP>(armMotor2));
    
    collectorMotor.reset(new VictorSP(MOTOR_COLLECTOR_PORT));
    lw->AddActuator("Collector", "COLLECTOR", std::static_pointer_cast<VictorSP>(collectorMotor));

    encoder.reset(new Encoder(ARM_ENCODER_A_PORT, ARM_ENCODER_B_PORT, false, Encoder::k4X));
    lw->AddSensor("Arm", "encoder", encoder);
    encoder->SetDistancePerPulse(0.1875);
    encoder->SetPIDSourceType(PIDSourceType::kDisplacement);
    encoder->SetReverseDirection(true);
    }
