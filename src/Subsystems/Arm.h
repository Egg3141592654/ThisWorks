// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#ifndef ARM_H
#define ARM_H
#include "Commands/PIDSubsystem.h"
#include "WPILib.h"

/**
 *
 *
 * @author ExampleAuthor
 */
class Arm: public PIDSubsystem {
private:
	// It's desirable that everything possible is private except
	// for methods that implement subsystem capabilities
	/*
	 * This is the first of two arm motors to use (initialized in the RobotMap class)
	 */
	std::shared_ptr<SpeedController> aRM_MOTOR_1;

	/*
	 * This is the second of the two motors to use (initialized in the RobotMap class)
	 */
	std::shared_ptr<SpeedController> aRM_MOTOR_2;

	/*
	 * This is the encoder to use to determine the PID position of the arm (initialized in RobotMap)
	 */
	std::shared_ptr<Encoder> encoder;

	/*
	 * The position of the robot at this point in time
	 */
	double currentPosition;

	/*
	 * This is a saved array of the last 10 values returned from the arm.
	 */
	double rollingAverage[10];

	/*
	 * This is the current index of the rolling average array (this will roll over in the update class)
	 */
	int rollingIndex = 0;

	/*
	 * This is the set point to look to attain in the PID loop
	 */
	double setPoint;

	/*
	 * This is an internal flag that tells if the PID is actually enabled.
	 */
	bool isEnabled;
public:
	/*
	 * Initializes a new instance of the Arm class. This contains the methods that will actually act on the
	 * arm (called from commands that require it).
	 */
	Arm();

	/*
	 * This will initialize any default commands that are tied to this subsystem (in this case MoveArm)
	 */
	void InitDefaultCommand();

	/*
	 * This method will return the encoder value nad update the rolling average of values.
	 *
	 * @return a double of the current encoder position.
	 */
	double ReturnPIDInput();

	/*
	 * This method determines what to actually do with the output from the PID (in this case, drive the arm)
	 *
	 * @param output: The output recieved from the PID controller.
	 */
	void UsePIDOutput(double output);

	/*
	 * This method will drive the arm motors at the speed passed in.
	 *
	 * @param speed: The speed which to drive the arm at.
	 */
	void Drive(float);

	/*
	 * This method will change the target of the PID loop to the value specified
	 *
	 * @param newTarget: This is the value of the new target to achieve
	 * @param isRelative: If this flag is set to true, we will only change the set point to be
	 * 	relative of the previous position.
	 */
	void SetNewPosition(double newTarget, bool isRelative=false);

	/*
	 * This method actually sets the position relative to the current setpoint (called from SetNewPosition
	 * with the isRelative flag set).
	 *
	 * @param stick: The joystick from which to read the first axis from to get a relative position.
	 */
	void SetNewRelativePosition(Joystick * stick);

	/*
	 * Gets the set point for the PID currently.
	 *
	 * @return The set point of the PID presently.
	 */
	double GetTarget();

	/*
	 * This method will enable the PID if needed.
	 *
	 * @param enabled: A flag that will turn the PID on (true) or off (false).
	 */
	void EnablePID(bool);

	/*
	 * This takes the rolling average and determines if the PID has driven the arm to the value requested.
	 *
	 * @return True if the arm is close enough.
	 */
	bool AtPosition(void);

	/*
	 * Sums the average of the past values of the encoder and returns the estimated position of the arm
	 *
	 * @return The estimated position of the arm.
	 */
	double GetRollingAverage(void);
};

#endif
